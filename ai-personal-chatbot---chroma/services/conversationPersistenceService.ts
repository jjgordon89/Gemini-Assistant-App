// Enhanced Conversation Persistence Service
// Provides long-term memory and session management

import { Message, ChatRole } from '../types';
import UnifiedMemoryService from './unifiedMemoryService';

export interface ConversationSession {
  id: string;
  title: string;
  createdAt: string;
  updatedAt: string;
  messageCount: number;
  userId?: string;
  metadata?: Record<string, any>;
}

export interface ConversationSummary {
  sessionId: string;
  summary: string;
  keyTopics: string[];
  createdAt: string;
}

export interface PersistenceStats {
  totalSessions: number;
  totalMessages: number;
  oldestSession?: string;
  newestSession?: string;
  averageSessionLength: number;
}

export class ConversationPersistenceService {
  private static instance: ConversationPersistenceService;
  private readonly sessionsKey = 'chroma_sessions';
  private readonly summariesKey = 'chroma_summaries';
  private readonly currentSessionKey = 'chroma_current_session';
  private currentSessionId: string | null = null;
  private memoryService: UnifiedMemoryService;

  private constructor() {
    this.memoryService = UnifiedMemoryService.getInstance();
  }

  public static getInstance(): ConversationPersistenceService {
    if (!ConversationPersistenceService.instance) {
      ConversationPersistenceService.instance = new ConversationPersistenceService();
    }
    return ConversationPersistenceService.instance;
  }

  /**
   * Initialize the persistence service
   */
  public async initialize(): Promise<void> {
    try {
      await this.memoryService.initialize();
      
      // Load current session if it exists
      const currentSessionId = localStorage.getItem(this.currentSessionKey);
      if (currentSessionId) {
        this.currentSessionId = currentSessionId;
      }
      
      console.log('Conversation persistence service initialized');
    } catch (error) {
      console.error('Failed to initialize conversation persistence service:', error);
      throw error;
    }
  }

  /**
   * Start a new conversation session
   */
  public async startNewSession(title?: string, userId?: string): Promise<string> {
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const session: ConversationSession = {
      id: sessionId,
      title: title || `Conversation ${new Date().toLocaleDateString()}`,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      messageCount: 0,
      userId,
      metadata: {}
    };

    await this.saveSession(session);
    this.currentSessionId = sessionId;
    localStorage.setItem(this.currentSessionKey, sessionId);

    console.log(`Started new conversation session: ${sessionId}`);
    return sessionId;
  }

  /**
   * Load an existing session
   */
  public async loadSession(sessionId: string): Promise<ConversationSession | null> {
    const sessions = this.getSessions();
    const session = sessions.find(s => s.id === sessionId);
    
    if (session) {
      this.currentSessionId = sessionId;
      localStorage.setItem(this.currentSessionKey, sessionId);
      console.log(`Loaded conversation session: ${sessionId}`);
    }
    
    return session || null;
  }

  /**
   * Get current session
   */
  public getCurrentSession(): ConversationSession | null {
    if (!this.currentSessionId) return null;
    
    const sessions = this.getSessions();
    return sessions.find(s => s.id === this.currentSessionId) || null;
  }
  /**
   * Add message to current session
   */
  public async addMessageToSession(message: Message): Promise<void> {
    if (!this.currentSessionId) {
      // Auto-create session if none exists
      await this.startNewSession();
    }

    // Store message in memory service
    await this.memoryService.storeMessage(
      message,
      [], // Embedding will be generated by memory service
      this.currentSessionId || undefined,
      { sessionId: this.currentSessionId }
    );

    // Update session metadata
    if (this.currentSessionId) {
      await this.updateSessionMessageCount(this.currentSessionId, 1);
    }
  }

  /**
   * Get messages for a session
   */
  public async getSessionMessages(sessionId: string, limit?: number): Promise<Message[]> {    try {
      const conversations = await this.memoryService.exportConversations();
      
      const sessionMessages = conversations
        .filter(conv => conv.metadata?.sessionId === sessionId)
        .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())
        .map(conv => ({
          id: conv.id || `${Date.now()}-${Math.random()}`,
          text: conv.text,
          sender: conv.role as ChatRole,
          timestamp: new Date(conv.timestamp)
        }));

      return limit ? sessionMessages.slice(-limit) : sessionMessages;
    } catch (error) {
      console.error('Error getting session messages:', error);
      return [];
    }
  }

  /**
   * Create session summary
   */
  public async createSessionSummary(sessionId: string): Promise<ConversationSummary | null> {
    try {
      const messages = await this.getSessionMessages(sessionId);
      
      if (messages.length === 0) return null;

      // Simple summarization (in production, this would use AI)
      const topics = this.extractKeyTopics(messages);
      const summary = this.generateSimpleSummary(messages);

      const conversationSummary: ConversationSummary = {
        sessionId,
        summary,
        keyTopics: topics,
        createdAt: new Date().toISOString()
      };

      await this.saveSummary(conversationSummary);
      return conversationSummary;
    } catch (error) {
      console.error('Error creating session summary:', error);
      return null;
    }
  }

  /**
   * Search across all sessions
   */
  public async searchAcrossSessions(
    query: string,
    limit: number = 10
  ): Promise<Array<{
    message: Message;
    sessionId: string;
    sessionTitle: string;
    relevanceScore: number;
  }>> {
    try {
      const results = await this.memoryService.searchSimilar(query, limit * 2); // Get more results to filter
      const sessions = this.getSessions();
      
      return results
        .map(result => {
          const sessionId = result.entry.metadata?.sessionId;
          const session = sessions.find(s => s.id === sessionId);
            return {
            message: {
              id: result.entry.id || `${Date.now()}-${Math.random()}`,
              text: result.entry.text,
              sender: result.entry.role as ChatRole,
              timestamp: new Date(result.entry.timestamp)
            },
            sessionId: sessionId || 'unknown',
            sessionTitle: session?.title || 'Unknown Session',
            relevanceScore: result.score
          };
        })
        .slice(0, limit);
    } catch (error) {
      console.error('Error searching across sessions:', error);
      return [];
    }
  }

  /**
   * Get all sessions
   */
  public getSessions(userId?: string): ConversationSession[] {
    try {
      const stored = localStorage.getItem(this.sessionsKey);
      const sessions: ConversationSession[] = stored ? JSON.parse(stored) : [];
      
      return userId ? sessions.filter(s => s.userId === userId) : sessions;
    } catch (error) {
      console.error('Error getting sessions:', error);
      return [];
    }
  }

  /**
   * Delete session
   */
  public async deleteSession(sessionId: string): Promise<void> {
    try {
      // Remove session from storage
      const sessions = this.getSessions();
      const updatedSessions = sessions.filter(s => s.id !== sessionId);
      localStorage.setItem(this.sessionsKey, JSON.stringify(updatedSessions));

      // Remove session messages from memory (this is a simplified approach)
      // In a full implementation, we'd need to selectively delete by session ID
      
      // Remove session summary
      const summaries = this.getSummaries();
      const updatedSummaries = summaries.filter(s => s.sessionId !== sessionId);
      localStorage.setItem(this.summariesKey, JSON.stringify(updatedSummaries));

      // If current session is deleted, clear it
      if (this.currentSessionId === sessionId) {
        this.currentSessionId = null;
        localStorage.removeItem(this.currentSessionKey);
      }

      console.log(`Deleted session: ${sessionId}`);
    } catch (error) {
      console.error('Error deleting session:', error);
      throw error;
    }
  }

  /**
   * Get persistence statistics
   */
  public getStats(): PersistenceStats {
    const sessions = this.getSessions();
    const totalSessions = sessions.length;
    
    if (totalSessions === 0) {
      return {
        totalSessions: 0,
        totalMessages: 0,
        averageSessionLength: 0
      };
    }

    const totalMessages = sessions.reduce((sum, session) => sum + session.messageCount, 0);
    const timestamps = sessions.map(s => s.createdAt).sort();
    
    return {
      totalSessions,
      totalMessages,
      oldestSession: timestamps[0],
      newestSession: timestamps[timestamps.length - 1],
      averageSessionLength: Math.round(totalMessages / totalSessions)
    };
  }

  /**
   * Export all sessions and summaries
   */
  public async exportData(): Promise<{
    sessions: ConversationSession[];
    summaries: ConversationSummary[];
    messages: any[];
  }> {
    try {
      const sessions = this.getSessions();
      const summaries = this.getSummaries();
      const messages = await this.memoryService.exportConversations();

      return { sessions, summaries, messages };
    } catch (error) {
      console.error('Error exporting data:', error);
      throw error;
    }
  }

  /**
   * Import sessions and data
   */
  public async importData(data: {
    sessions?: ConversationSession[];
    summaries?: ConversationSummary[];
    messages?: any[];
  }): Promise<void> {
    try {
      if (data.sessions) {
        const existingSessions = this.getSessions();
        const mergedSessions = [...existingSessions, ...data.sessions];
        // Remove duplicates based on ID
        const uniqueSessions = mergedSessions.filter((session, index, self) =>
          index === self.findIndex(s => s.id === session.id)
        );
        localStorage.setItem(this.sessionsKey, JSON.stringify(uniqueSessions));
      }

      if (data.summaries) {
        const existingSummaries = this.getSummaries();
        const mergedSummaries = [...existingSummaries, ...data.summaries];
        const uniqueSummaries = mergedSummaries.filter((summary, index, self) =>
          index === self.findIndex(s => s.sessionId === summary.sessionId)
        );
        localStorage.setItem(this.summariesKey, JSON.stringify(uniqueSummaries));
      }

      if (data.messages) {
        await this.memoryService.importConversations(data.messages);
      }

      console.log('Data imported successfully');
    } catch (error) {
      console.error('Error importing data:', error);
      throw error;
    }
  }

  // Private helper methods
  private async saveSession(session: ConversationSession): Promise<void> {
    const sessions = this.getSessions();
    const existingIndex = sessions.findIndex(s => s.id === session.id);
    
    if (existingIndex >= 0) {
      sessions[existingIndex] = session;
    } else {
      sessions.push(session);
    }
    
    localStorage.setItem(this.sessionsKey, JSON.stringify(sessions));
  }

  private async updateSessionMessageCount(sessionId: string, increment: number): Promise<void> {
    const sessions = this.getSessions();
    const session = sessions.find(s => s.id === sessionId);
    
    if (session) {
      session.messageCount += increment;
      session.updatedAt = new Date().toISOString();
      await this.saveSession(session);
    }
  }

  private async saveSummary(summary: ConversationSummary): Promise<void> {
    const summaries = this.getSummaries();
    const existingIndex = summaries.findIndex(s => s.sessionId === summary.sessionId);
    
    if (existingIndex >= 0) {
      summaries[existingIndex] = summary;
    } else {
      summaries.push(summary);
    }
    
    localStorage.setItem(this.summariesKey, JSON.stringify(summaries));
  }

  private getSummaries(): ConversationSummary[] {
    try {
      const stored = localStorage.getItem(this.summariesKey);
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.error('Error getting summaries:', error);
      return [];
    }
  }

  private extractKeyTopics(messages: Message[]): string[] {
    // Simple keyword extraction (in production, use NLP libraries)
    const allText = messages.map(m => m.text).join(' ').toLowerCase();
    const words = allText.split(/\s+/).filter(word => word.length > 3);
    const wordCount = new Map<string, number>();
    
    words.forEach(word => {
      wordCount.set(word, (wordCount.get(word) || 0) + 1);
    });
    
    return Array.from(wordCount.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([word]) => word);
  }
  private generateSimpleSummary(messages: Message[]): string {
    const messageCount = messages.length;
    const userMessages = messages.filter(m => m.sender === ChatRole.USER).length;
    const topics = this.extractKeyTopics(messages).slice(0, 3).join(', ');
    
    return `Conversation with ${messageCount} messages (${userMessages} from user). Key topics: ${topics || 'general discussion'}.`;
  }
}

export default ConversationPersistenceService;
